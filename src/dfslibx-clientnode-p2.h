#ifndef PR4_DFS_CLIENTNODE_H
#define PR4_DFS_CLIENTNODE_H

#include <string>
#include <vector>
#include <map>
#include <limits.h>
#include <chrono>
#include <mutex>

#include <grpcpp/grpcpp.h>
#include "../proto-src/dfs-service.grpc.pb.h"

/**
 * The containing structure used to pass async data
 */
template<typename ResponseT>
struct AsyncClientData {

    // Protobuf reply container
    ResponseT reply;

    // Context for the client. It could be used to convey extra information to
    // the server and/or tweak certain RPC behaviors.
    grpc::ClientContext context;

    // Storage for the status of the RPC upon completion.
    grpc::Status status;

    // Client Responder based off of the response message type
    std::unique_ptr<grpc::ClientAsyncResponseReader<ResponseT>> response_reader;

};

class DFSClientNode {

protected:

    /** The deadline timeout in milliseconds **/
    int deadline_timeout;

    /** The unique client id **/
    std::string client_id;

    /** The mount path **/
    std::string mount_path;

    /** Unmounting indicator - indicates when the client is unmounting **/
    bool unmounting;

    /** CRC table kept in memory for faster calculations **/
    CRC::Table<std::uint32_t, 32> crc_table;

    /** The service stub **/
    std::unique_ptr<dfs_service::DFSService::Stub> service_stub;

    /** The completion queue for async calls **/
    grpc::CompletionQueue completion_queue;

    /**
     * Utility function to wrap a filename with the mount path.
     *
     * @param filepath
     * @return
     */
    std::string WrapPath(const std::string& filepath);

public:
    /**
     * Constructor for the DFSClientNode class
     */
    DFSClientNode();

    /**
     * Destructor for the DFSClientNode class
     */
    ~DFSClientNode();

    /**
     * Sets the mount path on the client node
     * @param path
     */
    void SetMountPath(const std::string& path);

    /**
     * Sets the deadline timeout in milliseconds
     * @param deadline
     */
    void SetDeadlineTimeout(int deadline);

    /**
     * Overrides the autogenerated client id for testing
     */
     void SetClientId(const std::string& id);

    /**
     * Gets the current mount path for the client node
     * @return std::string
     */
    const std::string MountPath();

    /**
     * Sets the unmounting indicator - called by the client when the client unmounts
     */
    void Unmount();

    /**
     * Indicates if the client is currently un-mounting
     *
     * @return
     */
    bool Unmounting();

    /**
     * Retrieve the unique client id
     */

    const std::string ClientId();

    /**
     * Creates the RPC channel to be used by the library
     * to connect to the remote GRPC service.
     *
     * @param channel
     */
    void CreateStub(std::shared_ptr<grpc::Channel> channel);

    /**
     * Request write access to the server
     *
     * @param filename
     * @return bool
     */
    virtual grpc::StatusCode RequestWriteAccess(const std::string& filename) = 0;

    /**
     * Store a file from the mount path on to the RPC server
     * @param filename
     * @return grpc::StatusCode
     */
    virtual grpc::StatusCode Store(const std::string& filename) = 0;

    /**
     * Fetch a file from the RPC server and put it in the mount path
     * @param filename
     * @return grpc::StatusCode
     */
    virtual grpc::StatusCode Fetch(const std::string& filename) = 0;

    /**
     * Delete a file on the RPC server
     * @param filename
     * @return grpc::StatusCode
     */
    virtual grpc::StatusCode Delete(const std::string& filename) = 0;

    /**
     * Get or print a list from the RPC server.
     *
     * @param file_map - A map of filenames as keys and sizes as values. If NULL, the map can be ignored.
     *                   If not NULL, then the map should be filled in with the filenames and sizes.
     * @param display - If true, the system should print a list of files to stdout
     * @return grpc::StatusCode
     */
    virtual grpc::StatusCode List(std::map<std::string,int>* file_map = NULL, bool display = false) = 0;

    /**
     * Get or print the stat details for a given filename,
     *
     * If the provided `file_status` parameter is NULL, this function
     * should print the status details to stdout.
     *
     * Otherwise, the file_status parameter should contain a pointer to the
     * protobuf status object returned by the GRPC service.
     *
     * @param filename
     * @param file_status
     * @return grpc::StatusCode
     */
    virtual grpc::StatusCode Stat(const std::string& filename, void* file_status = NULL) = 0;

    /**
     * Watcher wrapper
     *
     * This method will get called whenever inotify signals
     * a change to a file. You may want to surround this with
     * an approprite set of locks and/or condition variables.
     */
     virtual void InotifyWatcherCallback(std::function<void()> callback) = 0;

    /**
     * Assembles the client's payload and sends it to the server.
     * Student's should not have to adjust this method
     */
    template<typename RequestT, typename ResponseT>
    void CallbackList() {

        // Data we are sending to the server.
        RequestT request;
        request.set_name("");

        // Call object to store rpc data
        AsyncClientData<ResponseT>* call_data = new AsyncClientData<ResponseT>;

        // stub_->PrepareAyncCallbackList() creates an RPC object, returning
        // an instance to store in "call_data" but does not actually start the RPC.
        // Because we are using the asynchronous API, we need to hold on to
        // the "call_data" instance in order to get updates from the ongoing RPC.
        call_data->response_reader =
            service_stub->PrepareAsyncCallbackList(&call_data->context, request, &completion_queue);

        // StartCall initiates the RPC call
        call_data->response_reader->StartCall();

        // Request that, upon completion of the RPC, "reply" be updated with the
        // server's response; "status" with the indication of whether the operation
        // was successful. Tag the request with the memory address of the call_data object.
        call_data->response_reader->Finish(&call_data->reply, &call_data->status, (void*)call_data);

    }

    /**
     * Initialize the callback list
     */
     virtual void InitCallbackList() = 0;
};
#endif
